<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Phaser, adaptive uil test (kies later 256 of 512)</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #f2f2f2; }
    #game { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; }
    canvas { max-width: 100%; max-height: 100%; image-rendering: auto; }
    .hud {
      position: fixed;
      left: 12px;
      bottom: 12px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      color: #222;
      background: rgba(255,255,255,0.92);
      padding: 10px 12px;
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.08);
      line-height: 1.45;
      max-width: 360px;
    }
    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 6px;
      background: rgba(0,0,0,0.08);
      margin: 0 2px;
      display: inline-block;
    }
  </style>
</head>
<body>
  <div id="game"></div>
  <div class="hud" id="hud"></div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>

  <script>
    const DPR = Math.min(window.devicePixelRatio || 1, 2);

    // Je kunt straks in productie hiervan maken:
    // 256 als default, 512 alleen als nodig
    const ASSETS = {
      "256": { key: "owl256", file: "assets/owl_idle_256.png", frame: 256, label: "256 geladen" },
      "512": { key: "owl512", file: "assets/owl_idle_512.png", frame: 512, label: "512 geladen" }
    };

    const config = {
      type: Phaser.AUTO,
      parent: "game",
      width: 900,
      height: 520,
      backgroundColor: "#f2f2f2",
      resolution: DPR,
      render: { antialias: true, roundPixels: false },
      scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
      scene: { preload, create, update }
    };

    new Phaser.Game(config);

    let mode = "256";     // start met 256
    let owl;
    let hud;
    let targetHeight = 240; // startgrootte in pixels op het scherm
    let lastUpdate = 0;

    function preload() {
      Object.values(ASSETS).forEach(a => {
        this.load.spritesheet(a.key, a.file, { frameWidth: a.frame, frameHeight: a.frame });
      });
    }

    function create() {
      hud = document.getElementById("hud");

      // Zet filtering op LINEAR voor illustratieve sprites
      Object.values(ASSETS).forEach(a => {
        const tex = this.textures.get(a.key);
        if (tex && tex.setFilter) tex.setFilter(Phaser.Textures.FilterMode.LINEAR);
      });

      // Animaties voor beide assets
      Object.values(ASSETS).forEach(a => {
        this.anims.create({
          key: a.key + "_idle",
          frames: this.anims.generateFrameNumbers(a.key, { start: 0, end: 3 }),
          frameRate: 6,
          repeat: -1
        });
      });

      owl = this.add.sprite(config.width / 2, config.height / 2, ASSETS[mode].key);
      owl.setOrigin(0.5, 0.5);
      owl.play(ASSETS[mode].key + "_idle");

      applyTargetHeight(this);

      this.input.keyboard.on("keydown", (ev) => {
        const k = ev.key;

        // Wissel asset
        if (k === "1") setMode(this, "256");
        if (k === "2") setMode(this, "512");

        // Maak groter of kleiner
        if (k === "+" || k === "=") { targetHeight = clamp(targetHeight + 20, 60, 480); applyTargetHeight(this); }
        if (k === "-" || k === "_") { targetHeight = clamp(targetHeight - 20, 60, 480); applyTargetHeight(this); }
      });
    }

    function setMode(scene, newMode) {
      if (mode === newMode) return;
      mode = newMode;

      const current = ASSETS[mode];
      owl.setTexture(current.key);
      owl.play(current.key + "_idle", true);

      applyTargetHeight(scene);
      updateHud(scene, true);
    }

    function applyTargetHeight(scene) {
      const a = ASSETS[mode];

      // Frame is vierkant, dus hoogte = frame
      const scale = targetHeight / a.frame;
      owl.setScale(scale);
      updateHud(scene, true);
    }

    function update(scene, time) {
      // HUD niet elke frame, maar 4x per seconde
      if (time - lastUpdate > 250) {
        lastUpdate = time;
        updateHud(scene, false);
      }
    }

    function updateHud(scene, force) {
      const a = ASSETS[mode];

      // Hoe groot is de sprite ongeveer op het scherm
      const displayH = a.frame * owl.scaleY;

      // Vuistregel
      // Als je sprite op het scherm hoger wordt dan ~260-300 px,
      // dan zie je vaak voordeel van 512 op retina
      const hint =
        displayH >= 280
          ? "Je toont de uil best groot, 512 kan zichtbaar mooier zijn."
          : "Deze grootte is vaak prima met 256, 512 is mogelijk overkill.";

      hud.innerHTML =
        "Toetsen: <span class='kbd'>1</span> 256, <span class='kbd'>2</span> 512, " +
        "<span class='kbd'>plus</span> groter, <span class='kbd'>min</span> kleiner<br><br>" +
        "devicePixelRatio: " + (window.devicePixelRatio || 1).toFixed(2) + "<br>" +
        "renderer resolution: " + DPR.toFixed(2) + "<br>" +
        "asset: " + a.label + "<br>" +
        "frame: " + a.frame + " px<br>" +
        "doel hoogte: " + targetHeight + " px<br>" +
        "actuele hoogte: " + displayH.toFixed(0) + " px<br><br>" +
        hint;
    }

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
  </script>
</body>
</html>
